
http://loka.developpez.com/tutoriel/sdl/timer/
Je ne sais pas comment organiser tout ca, si il faut mettre la classe dans un fichier  part et ensuite l'inclure dans uen autre
page etc! dis moi ce que tu en pense ! 


//Librairie standard
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//Pour utiliser la SDL
#include <SDL.h>
#include <SDL_ttf.h>




//Le Timer
class Timer
{
    private:
    //Le temps quand le timer est lancé
    int startTicks;

    //Le temps enregistré quand le Timer a été mis en pause
    int pausedTicks;

    //Le status du Timer
    bool paused;
    bool started;

    public:
    //Initialise les variables
    Timer();

    //Les différentes actions du timer
    void start();
    void stop();
    void pause();
    void unpause();

    //recupére le nombre de millisecondes depuis que le timer a été lancé
    //ou récupére le nombre de millisecondes depuis que le timer a été mis en pause
    int get_ticks();

    //Fonctions de vérification du status du timer
    bool is_started();
    bool is_paused();
};


Timer::Timer()
{
    //Initialisation des variables
    startTicks = 0;
    pausedTicks = 0;
    paused = false;
    started = false;
}


/*--------------- les methodes ------------------------*/

void Timer::start()
{
    //On demarre le timer
    started = true;

    //On enlève la pause du timer
    paused = false;

    //On récupére le temps courant
    startTicks = SDL_GetTicks();
}

void Timer::stop()
{
    //On stoppe le timer
    started = false;

    //On enlève la pause
    paused = false;
}

int Timer::get_ticks()
{
    //Si le timer est en marche
    if( started == true )
    {
        //Si le timer est en pause
        if( paused == true )
        {
            //On retourne le nombre de ticks quand le timer a été mis en pause
            return pausedTicks;
        }
        else
        {
            //On retourne le temps courant moins le temps quand il a démarré
            return SDL_GetTicks() - startTicks;
        }
    }

    //Si le timer n'est pas en marche
    return 0;
}


void Timer::pause()
{
    //Si le timer est en marche et pas encore en pause
    if( ( started == true ) && ( paused == false ) )
    {
        //On met en pause le timer
        paused = true;

        //On calcul le pausedTicks
        pausedTicks = SDL_GetTicks() - startTicks;
    }
}

void Timer::unpause()
{
    //Si le timer est en pause
    if( paused == true )
    {
        //on enlève la pause du timer
        paused = false;

        //On remet à zero le startTicks
        startTicks = SDL_GetTicks() - pausedTicks;

        //Remise à zero du pausedTicks
        pausedTicks = 0;
    }
}

bool Timer::is_started()
{
    return started;
}

bool Timer::is_paused()
{
    return paused;
}




/* LE MAIN ET DONC CREATION DU CHRONO*/
int main (int argc, char *argv[])
{
    //On construit le timer
    Timer myTimer;

    //On génére la surface de message
    startStop = TTF_RenderText_Solid( font, "Appuyer sur S pour demarrer ou stopper le timer", textColor );
    pause = TTF_RenderText_Solid( font, "Appuyer sur P pour mettre/enlever la pause du timer", textColor );

    //Mise en route du timer
    myTimer.start();

    //Tant que l'utilisateur n'a pas quitter
    while( quit == false )
    {
        //Tant qu'il y a un événement
        while( SDL_PollEvent( &event ) )
        {
            //Si une touche a été préssée
            if( event.type == SDL_KEYDOWN )
            {
                //Si "s" a été préssé
                if( event.key.keysym.sym == SDLK_s )
                {
                    //Si le timer est en marche
                    if( myTimer.is_started() == true )
                    {
                        //On stoppe le timer
                        myTimer.stop();
                    }
                    else
                    {
                        //Mise en marche du timer
                        myTimer.start();
                    }
                }


//Si "p" a été préssé
                if( event.key.keysym.sym == SDLK_p )
                {
                    //Si le timer est en pause
                    if( myTimer.is_paused() == true )
                    {
                        //On enlève la pause
                        myTimer.unpause();
                    }
                    else
                    {
                        //On met le timer en pause
                        myTimer.pause();
                    }
                }

                //On pose le fond
        apply_surface( 0, 0, background, screen );

        //On pose les surfaces
        apply_surface( ( SCREEN_WIDTH - startStop->w ) / 2, 200, startStop, screen );
        apply_surface( ( SCREEN_WIDTH - pause->w ) / 2, 250, pause, screen );


//Une chaîne temporaire
        char time[ 64 ];

        //On convertis time en une chaîne de caractère (on le tronque aussi à trois chiffres après la virgule)
        sprintf( time, "%.3f", (float)myTimer.get_ticks() / 1000 );

//mise en place de la surface time en texte
        seconds = TTF_RenderText_Solid( font, time, textColor );

        //On pose la surface
        apply_surface( ( SCREEN_WIDTH - seconds->w ) / 2, 0, seconds, screen );

        //On libère la surface de temps
        SDL_FreeSurface( seconds );

        //Mise à jour de l'écran
        if( SDL_Flip( screen ) == -1 )
        {
            return 1;
        }

}

